/* Auto-generated by genmsg_cpp for file /home/diego/fuerte_workspace/sandbox/aibo_server/msg/Joints.msg */
#ifndef AIBO_SERVER_MESSAGE_JOINTS_H
#define AIBO_SERVER_MESSAGE_JOINTS_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace aibo_server
{
template <class ContainerAllocator>
struct Joints_ {
  typedef Joints_<ContainerAllocator> Type;

  Joints_()
  : jointLF1(0.0)
  , jointLF2(0.0)
  , jointLF3(0.0)
  , jointLH1(0.0)
  , jointLH2(0.0)
  , jointLH3(0.0)
  , jointRF1(0.0)
  , jointRF2(0.0)
  , jointRF3(0.0)
  , jointRH1(0.0)
  , jointRH2(0.0)
  , jointRH3(0.0)
  , tailPan(0.0)
  , tailTilt(0.0)
  , headTilt(0.0)
  , headPan(0.0)
  , headNeck(0.0)
  , mouth(0.0)
  {
  }

  Joints_(const ContainerAllocator& _alloc)
  : jointLF1(0.0)
  , jointLF2(0.0)
  , jointLF3(0.0)
  , jointLH1(0.0)
  , jointLH2(0.0)
  , jointLH3(0.0)
  , jointRF1(0.0)
  , jointRF2(0.0)
  , jointRF3(0.0)
  , jointRH1(0.0)
  , jointRH2(0.0)
  , jointRH3(0.0)
  , tailPan(0.0)
  , tailTilt(0.0)
  , headTilt(0.0)
  , headPan(0.0)
  , headNeck(0.0)
  , mouth(0.0)
  {
  }

  typedef double _jointLF1_type;
  double jointLF1;

  typedef double _jointLF2_type;
  double jointLF2;

  typedef double _jointLF3_type;
  double jointLF3;

  typedef double _jointLH1_type;
  double jointLH1;

  typedef double _jointLH2_type;
  double jointLH2;

  typedef double _jointLH3_type;
  double jointLH3;

  typedef double _jointRF1_type;
  double jointRF1;

  typedef double _jointRF2_type;
  double jointRF2;

  typedef double _jointRF3_type;
  double jointRF3;

  typedef double _jointRH1_type;
  double jointRH1;

  typedef double _jointRH2_type;
  double jointRH2;

  typedef double _jointRH3_type;
  double jointRH3;

  typedef double _tailPan_type;
  double tailPan;

  typedef double _tailTilt_type;
  double tailTilt;

  typedef double _headTilt_type;
  double headTilt;

  typedef double _headPan_type;
  double headPan;

  typedef double _headNeck_type;
  double headNeck;

  typedef double _mouth_type;
  double mouth;


  typedef boost::shared_ptr< ::aibo_server::Joints_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::aibo_server::Joints_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct Joints
typedef  ::aibo_server::Joints_<std::allocator<void> > Joints;

typedef boost::shared_ptr< ::aibo_server::Joints> JointsPtr;
typedef boost::shared_ptr< ::aibo_server::Joints const> JointsConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::aibo_server::Joints_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::aibo_server::Joints_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace aibo_server

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::aibo_server::Joints_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::aibo_server::Joints_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::aibo_server::Joints_<ContainerAllocator> > {
  static const char* value() 
  {
    return "86bda1606b1e8eea8ce5b24eb34df225";
  }

  static const char* value(const  ::aibo_server::Joints_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x86bda1606b1e8eeaULL;
  static const uint64_t static_value2 = 0x8ce5b24eb34df225ULL;
};

template<class ContainerAllocator>
struct DataType< ::aibo_server::Joints_<ContainerAllocator> > {
  static const char* value() 
  {
    return "aibo_server/Joints";
  }

  static const char* value(const  ::aibo_server::Joints_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::aibo_server::Joints_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#\n\
#Header header\n\
#The Joints of the Aibo\n\
float64 jointLF1\n\
float64 jointLF2     \n\
float64 jointLF3     \n\
float64 jointLH1     \n\
float64 jointLH2 \n\
float64 jointLH3 \n\
float64 jointRF1\n\
float64 jointRF2\n\
float64 jointRF3\n\
float64 jointRH1\n\
float64 jointRH2\n\
float64 jointRH3\n\
float64 tailPan\n\
float64 tailTilt\n\
float64 headTilt\n\
float64 headPan\n\
float64 headNeck\n\
float64 mouth\n\
\n\
";
  }

  static const char* value(const  ::aibo_server::Joints_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::aibo_server::Joints_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::aibo_server::Joints_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.jointLF1);
    stream.next(m.jointLF2);
    stream.next(m.jointLF3);
    stream.next(m.jointLH1);
    stream.next(m.jointLH2);
    stream.next(m.jointLH3);
    stream.next(m.jointRF1);
    stream.next(m.jointRF2);
    stream.next(m.jointRF3);
    stream.next(m.jointRH1);
    stream.next(m.jointRH2);
    stream.next(m.jointRH3);
    stream.next(m.tailPan);
    stream.next(m.tailTilt);
    stream.next(m.headTilt);
    stream.next(m.headPan);
    stream.next(m.headNeck);
    stream.next(m.mouth);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct Joints_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::aibo_server::Joints_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::aibo_server::Joints_<ContainerAllocator> & v) 
  {
    s << indent << "jointLF1: ";
    Printer<double>::stream(s, indent + "  ", v.jointLF1);
    s << indent << "jointLF2: ";
    Printer<double>::stream(s, indent + "  ", v.jointLF2);
    s << indent << "jointLF3: ";
    Printer<double>::stream(s, indent + "  ", v.jointLF3);
    s << indent << "jointLH1: ";
    Printer<double>::stream(s, indent + "  ", v.jointLH1);
    s << indent << "jointLH2: ";
    Printer<double>::stream(s, indent + "  ", v.jointLH2);
    s << indent << "jointLH3: ";
    Printer<double>::stream(s, indent + "  ", v.jointLH3);
    s << indent << "jointRF1: ";
    Printer<double>::stream(s, indent + "  ", v.jointRF1);
    s << indent << "jointRF2: ";
    Printer<double>::stream(s, indent + "  ", v.jointRF2);
    s << indent << "jointRF3: ";
    Printer<double>::stream(s, indent + "  ", v.jointRF3);
    s << indent << "jointRH1: ";
    Printer<double>::stream(s, indent + "  ", v.jointRH1);
    s << indent << "jointRH2: ";
    Printer<double>::stream(s, indent + "  ", v.jointRH2);
    s << indent << "jointRH3: ";
    Printer<double>::stream(s, indent + "  ", v.jointRH3);
    s << indent << "tailPan: ";
    Printer<double>::stream(s, indent + "  ", v.tailPan);
    s << indent << "tailTilt: ";
    Printer<double>::stream(s, indent + "  ", v.tailTilt);
    s << indent << "headTilt: ";
    Printer<double>::stream(s, indent + "  ", v.headTilt);
    s << indent << "headPan: ";
    Printer<double>::stream(s, indent + "  ", v.headPan);
    s << indent << "headNeck: ";
    Printer<double>::stream(s, indent + "  ", v.headNeck);
    s << indent << "mouth: ";
    Printer<double>::stream(s, indent + "  ", v.mouth);
  }
};


} // namespace message_operations
} // namespace ros

#endif // AIBO_SERVER_MESSAGE_JOINTS_H

